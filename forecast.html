
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Forecast</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: #f0f2f5;
            padding: 20px;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .main-container {
            max-width: 800px;
           margin: 0 auto;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left {
            flex: 1;
        }
        
        .header-left h1 {
            font-size: 20px;
            margin-bottom: 3px;
        }
        
        .header-left .subtitle {
            opacity: 0.9;
            font-size: 11px;
            margin-top: 3px;
        }
        
        /* Location Search */
        .location-search {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 20px;
            transition: background 0.2s;
        }
        
        .location-search:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .location-search input {
            background: transparent;
            border: none;
            color: white;
            outline: none;
            width: 150px;
            font-size: 13px;
        }
        
        .location-search input::placeholder {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .location-search button {
            background: rgba(255, 255, 255, 0.3);
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .location-search button:hover {
            background: rgba(255, 255, 255, 0.4);
        }
        
        .last-updated {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        /* Current Conditions */
        .current-conditions {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
            overflow-x: auto;
        }
        
        .current-temp {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-right: 20px;
            border-right: 1px solid #e0e0e0;
            min-width: 120px;
        }
        
        .current-temp-value {
            font-size: 45px;
            font-weight: 300;
            line-height: 1;
        }
        
        .current-temp-feels {
            font-size: 15px;
            color: #666;
        }
        
        .current-condition-icon {
            font-size: 32px;
        }
        
        .current-stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .current-stat {
            display: flex;
            flex-direction: column;
            min-width: 60px;
        }
        
        .current-stat-value {
            font-size: 22px;
            font-weight: 500;
            color: #333;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .current-stat-label {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
                
        .wind-arrow {
            display: inline-block;
            font-size: 18px;
            transform-origin: center;
        }
		
        /* Detailed Forecast Section */
        .detailed-forecast {
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            padding: 10px 20px;
        }
        
        .forecast-period {
            margin-bottom: 12px;
        }
        
        .forecast-period:last-child {
            margin-bottom: 0;
        }
        
        .forecast-period-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .forecast-period-text {
            font-size: 13px;
            color: #555;
            line-height: 1.4;
        }
        
        /* Daily Forecast Strip */
        .daily-forecast {
            background: #fff;
            border-bottom: 2px solid #e0e0e0;
            position: relative;
            overflow-x: auto;
            padding: 0 11px;
        }
        
        .daily-forecast-container {
            display: flex;
            position: relative;
            min-height: 100px;
        }
        
        .day-forecast {
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 5px 5px;
            text-align: center;
            transition: background-color 0.2s;
            position: relative;
            cursor: pointer;
            display: flex;
            flex-direction: column;
			max-width: 101px;
 			min-width: 8px;
        }
        
        .day-forecast:last-child {
            border-right: none;
        }
        
        .day-forecast:hover, .day-forecast.selected {
            background-color: #f0f9ff;
        }
        
        .day-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .day-icon {
            font-size: 30px;
            margin: 5px 0;
        }
        
        .day-temps {
            display: flex;
            justify-content: center;
            gap: 8px; 
            font-size: 18px;
            margin-bottom: 0px;
        }
        
        .day-high {
            font-weight: 600;
            color: #ef4444;
        }
        
        .day-low {
            color: #3b82f6;
        }
        
        .day-detail {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            padding: 0 5px;
            line-height: 1.3;
            flex-grow: 1;
            display: flex;
            align-items: center;
            text-align: left;
        }
        
        /* Charts */
        .charts-wrapper {
            padding: 3px;
            background: #fafafa;
            position: relative;
            overflow-x: auto;
            touch-action: pan-y;
			min-width: 700px;
        }
        
        .chart-section {
            margin-bottom: 0px;
            position: relative;
        }
        
        .chart-container {
            position: relative;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 20px 10px 5px 0px;
            overflow: hidden;
        }
        
        .chart-container.temperature-chart {
            height: 150px;
        }
        
        .chart-container.combined-chart {
            height: 130px;
        }
        
        .chart-container.precipitation-amount-chart {
            height: 100px;
        }
        
        .chart-container.wind-chart {
            height: 150px;
        }
        
        .chart-label {
            position: absolute;
            left: 10px;
            top: 5px;
            font-size: 10px;
            font-weight: 600;
            color: #666;
            z-index: 10;
        }
        
        /* Crosshair tooltip */
        .crosshair-line {
            position: absolute;
            width: 1px;
            background: rgba(0, 0, 0, 0.3);
            pointer-events: none;
            top: 0;
            bottom: 0;
            display: none;
            z-index: 1000;
        }
        
        .crosshair-time {
            position: absolute;
            top: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        .chart-value-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1001;
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            text-align: center;
            padding: 40px;
            color: #d32f2f;
        }

        canvas {
            max-height: 100%;
            cursor: crosshair;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2"></script>
</head>
<body>

    <div class="main-container">
        <div class="header">
            <div class="header-left">
                <h1><span id="locationName">Tysons, Virginia</span></h1>
                <div class="subtitle" id="locationDetails">Loading...</div>
                <div class="last-updated" id="lastUpdated">Last updated: --</div>
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <button onclick="useMyLocation()" style="background: rgba(255, 255, 255, 0.2); border: none; color: white; padding: 5px 10px; border-radius: 15px; cursor: pointer; font-size: 12px;" title="Use GPS location">âŠ• My Location</button>
                <div class="location-search">
                    <input type="text" id="locationInput" placeholder="Search location..." />
                    <button onclick="searchLocation()">Go</button>
                </div>
            </div>
        </div>
        
        <!-- Current Conditions -->
        <div class="current-conditions" id="currentConditions">
            <div class="loading">Loading current conditions...</div>
        </div>
        
        <!-- Detailed Forecast Details -->
        <div class="detailed-forecast" id="detailedForcast" style="display: none;">
            <!-- Detailed forecast will be inserted here -->
        </div>
        
        <!-- Daily Forecast Strip -->
        <div class="daily-forecast">
            <div class="daily-forecast-container" id="dailyForecast">
                <!-- Daily forecasts will be inserted here -->
            </div>
        </div>
        
        <!-- Charts -->
        <div class="charts-wrapper">
            <div class="loading" id="loading">Loading forecast data...</div>
            <div id="chartsContainer" style="display: none;">
                <!-- Crosshair line that spans all charts -->
                <div class="crosshair-line" id="crosshairLine">
                    <div class="crosshair-time" id="crosshairTime"></div>
                </div>
                
                <!-- Temperature Chart -->
                <div class="chart-section">
                    <div class="chart-label">TEMPERATURE & FEELS LIKE</div>
                    <div class="chart-container temperature-chart">
                        <canvas id="tempChart"></canvas>
                        <div class="chart-value-tooltip" id="tempTooltip"></div>
                    </div>
                </div>
                
                <!-- Combined Chart -->
                <div class="chart-section">
                    <div class="chart-label">HUMIDITY, CLOUD COVER & PRECIPITATION</div>
                    <div class="chart-container combined-chart">
                        <canvas id="combinedChart"></canvas>
                        <div class="chart-value-tooltip" id="combinedTooltip"></div>
                    </div>
                </div>
                
                <!-- Precipitation Amount Chart -->
                <div class="chart-section">
                    <div class="chart-label">PRECIPITATION AMOUNT</div>
                    <div class="chart-container precipitation-amount-chart">
                        <canvas id="precipAmountChart"></canvas>
                        <div class="chart-value-tooltip" id="precipTooltip"></div>
                    </div>
                </div>
                
                <!-- Wind Chart -->
                <div class="chart-section">
                    <div class="chart-label">WIND SPEED & GUSTS</div>
                    <div class="chart-container wind-chart">
                        <canvas id="windChart"></canvas>
                        <div class="chart-value-tooltip" id="windTooltip"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let charts = {};
        let currentLat = 38.92;
        let currentLon = -77.23;
        let currentLocationName = "Tysons, Virginia";
        let currentElevation = null;
        let globalHourlyData = null;
        let globalDayBoundaries = [];
        let globalDailyPeriods = [];
        let selectedDayIndex = null;
        
        // Chart configuration defaults
        Chart.defaults.font.size = 10;
        Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif';
        
        // Register annotation plugin
        Chart.register(window['chartjs-plugin-annotation']);
        
        async function searchLocation() {
            const input = document.getElementById('locationInput').value.trim();
            if (!input) return;
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(input)}&limit=1`);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const location = data[0];
                    currentLat = parseFloat(location.lat);
                    currentLon = parseFloat(location.lon);
                    currentLocationName = location.display_name.split(',').slice(0, 2).join(', ');
                    document.getElementById('locationName').textContent = currentLocationName;
                    
                    // ADD THIS LINE - Update URL with new location
                    updateURL(currentLat, currentLon, currentLocationName);
                    
                    // Reset elevation when changing locations
                    currentElevation = null;
                    
                    // Destroy existing charts before reinitializing
                    Object.values(charts).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                    charts = {};
                    
                    document.getElementById('locationInput').value = '';
                    initializeForecast();
                } else {
                    alert('Location not found. Please try another search.');
                }
            } catch (error) {
                console.error('Geocoding error:', error);
                alert('Error searching for location. Please try again.');
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('locationInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchLocation();
                }
            });
        });
        
        // Update location details
        function updateLocationDetails() {
            const elevText = currentElevation !== null && currentElevation !== undefined ? 
                `${Math.round(currentElevation * 3.28084)} ft` : '';
            const coordsText = `${currentLat.toFixed(4)}Â°, ${currentLon.toFixed(4)}Â°`;
            document.getElementById('locationDetails').textContent = `${coordsText}${elevText ? ' â€¢ ' + elevText : ''}`;
        }
        

		
		
		
		
        // Utility functions
        function parseValidTime(validTimeStr) {
            const [timeStr, durationStr] = validTimeStr.split('/');
            const startTime = new Date(timeStr);
            
            let durationHours = 1;
            if (durationStr) {
                const durationMatch = durationStr.match(/PT(\d+)H/);
                if (durationMatch) {
                    durationHours = parseInt(durationMatch[1]);
                }
            }
            
            const endTime = new Date(startTime.getTime() + durationHours * 3600000);
            
            return { startTime, endTime, durationHours };
        }
        
        function getValueAtTime(values, targetTime) {
            if (!values || !values.length) return null;
            
            const targetDate = new Date(targetTime);
            
            for (const item of values) {
                const { startTime, endTime } = parseValidTime(item.validTime);
                if (targetDate >= startTime && targetDate < endTime) {
                    return item.value;
                }
            }
            
            return null;
        }
        
        function calculateFeelsLike(temp, humidity, windSpeed) {
		console.log("test");
           if (temp <= 50 && windSpeed > 3) {
                return Math.round(35.74 + 0.6215 * temp - 35.75 * Math.pow(windSpeed, 0.16) + 0.4275 * temp * Math.pow(windSpeed, 0.16));
            } else if (temp >= 80) {
                const c1 = -42.379, c2 = 2.04901523, c3 = 10.14333127;
                const c4 = -0.22475541, c5 = -0.00683783, c6 = -0.05481717;
                const c7 = 0.00122874, c8 = 0.00085282, c9 = -0.00000199;
                
                let heatIndex = c1 + c2*temp + c3*humidity + c4*temp*humidity + c5*temp*temp + 
                               c6*humidity*humidity + c7*temp*temp*humidity + c8*temp*humidity*humidity + 
                               c9*temp*temp*humidity*humidity;
				console.log(Math.round(heatIndex));			   
                return Math.round(heatIndex);
            }
			console.log(Math.round(temp));
            return Math.round(temp);
        }
        
        function getWeatherIcon(conditions, precipProb = 0) {
            if (!conditions) return 'â˜ï¸';
            
            const forecast = conditions.toLowerCase();
            
            // Only show rain/snow icons if precipitation probability > 50%
            if (precipProb > 50) {
                if (forecast.includes('storm') || forecast.includes('thunder')) return 'â›ˆï¸';
                if (forecast.includes('rain') || forecast.includes('shower')) return 'ðŸŒ§ï¸';
                if (forecast.includes('snow')) return 'â„ï¸';
            }
            
            if (forecast.includes('sunny') || forecast.includes('clear')) return 'â˜€ï¸';
            if (forecast.includes('partly')) return 'â›…';
            if (forecast.includes('cloudy')) return 'â˜ï¸';
            if (forecast.includes('fog')) return 'ðŸŒ«ï¸';
            if (forecast.includes('wind')) return 'ðŸ’¨';
            return 'â˜ï¸';
        }
        
        function getWeatherDescription(cloudCover, precipProb, temp) {
            if (precipProb > 60) return 'Rainy';
            if (precipProb > 30) return 'Chance of Rain';
            if (cloudCover < 20) return 'Clear';
            if (cloudCover < 50) return 'Partly Cloudy';
            if (cloudCover < 80) return 'Mostly Cloudy';
            return 'Cloudy';
        }
        
        function getWindArrow(degrees) {
            if (degrees === null || degrees === undefined) return '';
            const rotation = degrees;
            return '<span class="wind-arrow" style="transform: rotate(' + rotation + 'deg);">â†“</span>';
        }
        
        function getSunTimes(date, lat, lon) {
            const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
            const P = Math.asin(0.39795 * Math.cos(0.98563 * (dayOfYear - 173) * Math.PI / 180));
            const sunrise = -Math.tan(lat * Math.PI / 180) * Math.tan(P);
            
            if (sunrise < -1) return { sunrise: 0, sunset: 24 };
            else if (sunrise > 1) return { sunrise: 12, sunset: 12 };
            
            const hourAngle = Math.acos(sunrise) * 180 / Math.PI;
            const sunriseTime = 12 - hourAngle / 15 - lon / 15 - date.getTimezoneOffset() / 60;
            const sunsetTime = 12 + hourAngle / 15 - lon / 15 - date.getTimezoneOffset() / 60;
            
            const B = 2 * Math.PI * (dayOfYear - 81) / 365;
            const E = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
            
            return {
                sunrise: sunriseTime - E / 60,
                sunset: sunsetTime - E / 60
            };
        }
        
        async function getForecastData() {
            try {
                const gridResponse = await fetch(`https://api.weather.gov/points/${currentLat},${currentLon}`);
                if (!gridResponse.ok) throw new Error(`Grid API Error: ${gridResponse.status}`);
                const gridData = await gridResponse.json();
                
                const gridForecastResponse = await fetch(gridData.properties.forecastGridData);
                if (!gridForecastResponse.ok) throw new Error(`Grid Forecast Error: ${gridForecastResponse.status}`);
                const gridForecastData = await gridForecastResponse.json();
                
                // Get elevation from gridded forecast data
                if (gridForecastData.properties && gridForecastData.properties.elevation && 
                    gridForecastData.properties.elevation.value !== undefined) {
                    currentElevation = gridForecastData.properties.elevation.value;
                    console.log('Elevation from grid forecast:', currentElevation);
                }
                
                const dailyResponse = await fetch(gridData.properties.forecast);
                if (!dailyResponse.ok) throw new Error(`Daily Forecast Error: ${dailyResponse.status}`);
                const dailyData = await dailyResponse.json();
                
                return {
                    gridded: gridForecastData.properties,
                    daily: dailyData.properties.periods
                };
            } catch (error) {
                console.error("Error fetching forecast data:", error);
                document.getElementById('loading').innerHTML = `<div class="error">Error loading forecast: ${error.message}</div>`;
                throw error;
            }
        }
        
        function processGriddedDataToHourly(gridded) {
			// Find the earliest time in the gridded data
			let earliestTime = null;
			const now = new Date();
			
			// Check temperature values for the earliest time
			if (gridded.temperature?.values?.length > 0) {
				const firstValue = gridded.temperature.values[0];
				const { startTime } = parseValidTime(firstValue.validTime);
				earliestTime = startTime;
			}
			
			// If no historical data found, start from current hour
			if (!earliestTime || earliestTime >= now) {
				earliestTime = new Date(now);
				earliestTime.setMinutes(0, 0, 0);
			}
			
			const hourlyData = [];
			
			// Calculate total hours from earliest to 7 days out
			const endTime = new Date(now.getTime() + 7 * 24 * 3600000);
			const totalHours = Math.ceil((endTime - earliestTime) / 3600000);

					
			for (let i = 0; i < totalHours; i++) {
				 const hourTime = new Date(earliestTime.getTime() + i * 3600000);
               
                const tempC = getValueAtTime(gridded.temperature?.values, hourTime);
                const tempF = tempC !== null ? Math.round(tempC * 9/5 + 32) : null;
                
                const windSpeedKmh = getValueAtTime(gridded.windSpeed?.values, hourTime);
                const windSpeedMph = windSpeedKmh !== null ? Math.round(windSpeedKmh * 0.621371) : 0;
                
                const windGustKmh = getValueAtTime(gridded.windGust?.values, hourTime);
                const windGustMph = windGustKmh !== null && windGustKmh > 0 ? Math.round(windGustKmh * 0.621371) : null;
                
                const windDirection = getValueAtTime(gridded.windDirection?.values, hourTime);
                const windDirStr = windDirection !== null ?
                    ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(windDirection / 22.5) % 16] : '';
                
                const humidity = getValueAtTime(gridded.relativeHumidity?.values, hourTime) || 50;
                const cloudCover = getValueAtTime(gridded.skyCover?.values, hourTime) || 0;
                const precipProbability = getValueAtTime(gridded.probabilityOfPrecipitation?.values, hourTime) || 0;
                const precipAmountMm = getValueAtTime(gridded.quantitativePrecipitation?.values, hourTime) || 0;
                const precipAmountIn = precipAmountMm * 0.0393701;
                
                const apparentTempC = getValueAtTime(gridded.apparentTemperature?.values, hourTime);
				
				let feelsLike = null;
				
				// VALIDATION: Check if apparent temperature from API is realistic
				// Apparent temp should be within reasonable bounds of actual temp
				// and never below -60Â°C (-76Â°F) or above 60Â°C (140Â°F) for populated areas
				const isRealisticApparentTemp = (tempC, apparentC) => {
					if (apparentC === null || apparentC === undefined) return false;
					if (apparentC < -60 || apparentC > 60) return false;  // Absolute bounds check
					if (tempC !== null) {
						// Apparent temp shouldn't differ from actual by more than 30Â°C
						const diff = Math.abs(apparentC - tempC);
						if (diff > 30) return false;
					}
					return true;
				};
				
				if (apparentTempC !== null && isRealisticApparentTemp(tempC, apparentTempC)) {
					// API value is reasonable, use it
					feelsLike = Math.round(apparentTempC * 9/5 + 32);
				} else {
					// API value is bad or missing, calculate it ourselves
					if (apparentTempC !== null && !isRealisticApparentTemp(tempC, apparentTempC)) {
						console.warn(`Bad apparent temp from API at ${hourTime.toISOString()}: ${apparentTempC}Â°C (${Math.round(apparentTempC * 9/5 + 32)}Â°F), actual temp: ${tempC}Â°C - calculating instead`);
					}
					
					if (tempF !== null) {
						feelsLike = calculateFeelsLike(tempF, humidity, windSpeedMph);
					}
				}
                
                const weather = getValueAtTime(gridded.weather?.values, hourTime);
                
                hourlyData.push({
                    time: hourTime,
                    temperature: tempF,
                    feelsLike: feelsLike,
                    windSpeed: windSpeedMph,
                    windGust: windGustMph,
                    windDirection: windDirStr,
                    windDegrees: windDirection,
                    humidity: Math.round(humidity),
                    cloudCover: Math.round(cloudCover),
                    precipProbability: Math.round(precipProbability),
                    precipAmount: precipAmountIn,
                    weather: weather,
                    description: getWeatherDescription(cloudCover, precipProbability, tempF)
                });
            }
            
            return hourlyData.filter(h => h.temperature !== null);
        }
        
        function createCurrentConditions(hourlyData) {
            if (!hourlyData || hourlyData.length === 0) {
                document.getElementById('currentConditions').innerHTML = '<div style="padding: 15px; color: #666;">Current conditions unavailable</div>';
                return;
            }
            
            const current = hourlyData[0];
            
            const html = `
                <div class="current-temp">
                    <div>
                        <div class="current-temp-value">${current.temperature}Â°</div>
                        <div class="current-temp-feels">Feels ${current.feelsLike}Â°</div>
                    </div>
                    <div class="current-condition-icon">${getWeatherIcon(current.description, current.precipProbability)}</div>
                </div>
                <div class="current-stats">
                    <div class="current-stat">
                        <div class="current-stat-value">
                            ${getWindArrow(current.windDegrees)}
                            ${current.windSpeed}
                        </div>
                        <div class="current-stat-label">Wind ${current.windDirection} mph</div>
                    </div>
                    ${current.windGust ? `
                        <div class="current-stat">
                            <div class="current-stat-value">${current.windGust}</div>
                            <div class="current-stat-label">Gusts mph</div>
                        </div>
                    ` : ''}
                    <div class="current-stat">
                        <div class="current-stat-value">${current.humidity}%</div>
                        <div class="current-stat-label">Humidity</div>
                    </div>
                </div>
            `;
            
            document.getElementById('currentConditions').innerHTML = html;
        }
        
        function showForecastForDay(dayIndex) {
            if (dayIndex === null || !globalDailyPeriods.length) {
                createDetailedForcast(globalDailyPeriods);
                return;
            }
            
            // Find the matching daily periods for the selected day
            const dayOffset = dayIndex * 2;
            let dayPeriod = null;
            let nightPeriod = null;
            
            for (let i = dayOffset; i < Math.min(dayOffset + 2, globalDailyPeriods.length); i++) {
                const period = globalDailyPeriods[i];
                if (period.isDaytime) {
                    dayPeriod = period;
                } else {
                    nightPeriod = period;
                }
            }
            
            // Display the forecast
            let html = '';
            
            if (dayPeriod) {
                const dayName = new Date(dayPeriod.startTime).toLocaleDateString('en-US', { weekday: 'long' });
                html += `
                    <div class="forecast-period">
                        <div class="forecast-period-title">${dayName}</div>
                        <div class="forecast-period-text">${dayPeriod.detailedForecast}</div>
                    </div>
                `;
            }
            
            if (nightPeriod) {
                const nightName = dayPeriod ? 
                    new Date(dayPeriod.startTime).toLocaleDateString('en-US', { weekday: 'long' }) + ' Night' : 
                    'Tonight';
                html += `
                    <div class="forecast-period">
                        <div class="forecast-period-title">${nightName}</div>
                        <div class="forecast-period-text">${nightPeriod.detailedForecast}</div>
                    </div>
                `;
            }
            
            document.getElementById('detailedForcast').innerHTML = html;
            document.getElementById('detailedForcast').style.display = 'block';
        }
        
        function createDetailedForcast(dailyPeriods) {
            const now = new Date();
            const currentHour = now.getHours();
            
            // Between 5pm (17) and 6am (6), show Tonight and Tomorrow
            const showTonightTomorrow = currentHour >= 17 || currentHour < 6;
            
            let firstPeriod = null;
            let secondPeriod = null;
            let firstTitle = '';
            let secondTitle = '';
            
            if (showTonightTomorrow) {
                // Find tonight and tomorrow
                for (let i = 0; i < dailyPeriods.length; i++) {
                    const period = dailyPeriods[i];
                    if (!firstPeriod && !period.isDaytime) {
                        firstPeriod = period;
                        firstTitle = 'Tonight';
                    } else if (firstPeriod && !secondPeriod && period.isDaytime) {
                        secondPeriod = period;
                        secondTitle = 'Tomorrow';
                        break;
                    }
                }
            } else {
                // Find today and tonight
                for (let i = 0; i < dailyPeriods.length; i++) {
                    const period = dailyPeriods[i];
                    if (!firstPeriod && period.isDaytime) {
                        firstPeriod = period;
                        firstTitle = 'Today';
                    } else if (firstPeriod && !secondPeriod && !period.isDaytime) {
                        secondPeriod = period;
                        secondTitle = 'Tonight';
                        break;
                    }
                }
            }
            
            if (!firstPeriod && !secondPeriod) {
                document.getElementById('detailedForcast').style.display = 'none';
                return;
            }
            
            let html = '';
            
            if (firstPeriod) {
                html += `
                    <div class="forecast-period">
                        <div class="forecast-period-title">${firstTitle}</div>
                        <div class="forecast-period-text">${firstPeriod.detailedForecast}</div>
                    </div>
                `;
            }
            
            if (secondPeriod) {
                html += `
                    <div class="forecast-period">
                        <div class="forecast-period-title">${secondTitle}</div>
                        <div class="forecast-period-text">${secondPeriod.detailedForecast}</div>
                    </div>
                `;
            }
            
            document.getElementById('detailedForcast').innerHTML = html;
            document.getElementById('detailedForcast').style.display = 'block';
        }
        
        function createDailyForecast(dailyPeriods, hourlyData) {
            globalDailyPeriods = dailyPeriods;
            
            // Calculate day boundaries
            const boundaries = [];
            let currentDay = null;
            
            hourlyData.forEach((hour, index) => {
                const dayStr = hour.time.toDateString();
                if (dayStr !== currentDay) {
                    boundaries.push(index);
                    currentDay = dayStr;
                }
            });
            
            globalDayBoundaries = boundaries;
            
            const now = new Date();
            const currentHour = now.getHours();
			const currentMinutes = now.getMinutes();
            const isPast5PM = currentHour >= 17;
			
			// Calculate percentage of day passed (0 at midnight, 1 at 11:59 PM)
			const percentOfDayPassed = (currentHour * 60 + currentMinutes) / (24 * 60);
			// Calculate dynamic left padding: starts at 105px at midnight, ends at 5px at end of day
			const dynamicLeftPadding = 5 + (101 * (1 - percentOfDayPassed));
	
            // Create day groups based on boundaries
            const days = [];
            for (let i = 0; i < boundaries.length && i < 7; i++) {
                const startIdx = boundaries[i];
                const endIdx = boundaries[i + 1] || hourlyData.length;
                const dayHours = hourlyData.slice(startIdx, endIdx);
                
                if (dayHours.length > 0) {
                    const temps = dayHours.map(h => h.temperature).filter(t => t !== null);
                    const date = dayHours[0].time;
                    const isToday = i === 0;
                    
                    // Find matching daily forecast with precipitation
                    let dayPeriod = null;
                    let maxPrecipProb = 0;
                    
                    for (const period of dailyPeriods) {
                        const periodDate = new Date(period.startTime);
                        if (periodDate.toDateString() === date.toDateString() && period.isDaytime) {
                            dayPeriod = period;
                            // Get max precipitation probability for the day
                            maxPrecipProb = Math.max(...dayHours.map(h => h.precipProbability));
                            break;
                        }
                    }
                    
                    days.push({
                        date: date,
                        high: isToday && isPast5PM ? null : Math.max(...temps),
                        low: Math.min(...temps),
                        hoursCount: dayHours.length,
                        startIdx: startIdx,
                        endIdx: endIdx,
                        precipProb: maxPrecipProb,
                        description: dayPeriod ? dayPeriod.shortForecast : dayHours[Math.floor(dayHours.length / 2)].description,
                        dayIndex: i
                    });
                }
            }
            
            // Calculate total width for proper percentage
            const totalHours = hourlyData.length;
            
			// In the HTML generation part:
			const html = days.map((day, index) => {
				const dayName = day.date.toLocaleDateString('en-US', { 
					weekday: 'short', 
					month: 'numeric',
					day: 'numeric'
				});
				
				const widthPercent = (day.hoursCount / totalHours) * 100;
				const highTemp = day.high !== null ? `${Math.round(day.high)}Â°` : '--';
				
				// Apply dynamic padding only to the first day (today)
				const leftPadding = index === 0 ? dynamicLeftPadding : 5;
				
				return `
					<div class="day-forecast" 
						 style="flex: 0 0 ${widthPercent}%; max-width: 101px; padding-left: ${leftPadding}px;"
						 onclick="selectDay(${day.dayIndex})">
						<div class="day-name">${dayName}</div>
						<div class="day-icon">${getWeatherIcon(day.description, day.precipProb)}</div>
						<div class="day-temps">
							<span class="day-high">${highTemp}</span>
							<span class="day-low">${Math.round(day.low)}Â°</span>
						</div>
						<div class="day-detail">${day.description}</div>
					</div>
				`;
			}).join('');
			
			document.getElementById('dailyForecast').innerHTML = html;
        }
        
        function selectDay(dayIndex) {
            // Remove previous selection
            document.querySelectorAll('.day-forecast').forEach((el, i) => {
                el.classList.toggle('selected', i === dayIndex);
            });
            
            // Update selected day and show forecast
            selectedDayIndex = selectedDayIndex === dayIndex ? null : dayIndex;
            showForecastForDay(dayIndex);
        }
        
        function getNightAnnotations(hourlyData) {
            const annotations = [];
            let inNight = false;
            let nightStart = null;
            
            hourlyData.forEach((hour, index) => {
                const date = hour.time;
                const hourNum = date.getHours();
                const sunTimes = getSunTimes(date, currentLat, currentLon);
                
                const sunriseHour = Math.round(sunTimes.sunrise);
                const sunsetHour = Math.round(sunTimes.sunset);
                const isNight = hourNum < sunriseHour || hourNum >= sunsetHour;
                
                if (isNight && !inNight) {
                    nightStart = index;
                    inNight = true;
                } else if (!isNight && inNight) {
                    if (nightStart !== null) {
                        annotations.push({
                            type: 'box',
                            xMin: nightStart - 0.5,
                            xMax: index - 0.5,
                            backgroundColor: 'rgba(20, 20, 50, 0.04)',
                            borderWidth: 0
                        });
                    }
                    inNight = false;
                    nightStart = null;
                }
            });
            
            if (inNight && nightStart !== null) {
                annotations.push({
                    type: 'box',
                    xMin: nightStart - 0.5,
                    xMax: hourlyData.length - 0.5,
                    backgroundColor: 'rgba(20, 20, 50, 0.04)',
                    borderWidth: 0
                });
            }
            
            return annotations;
        }
        
        function setupCrosshair() {
            const chartsContainer = document.getElementById('chartsContainer');
            const canvases = chartsContainer.querySelectorAll('.chart-container');
            
            canvases.forEach(canvas => {
                // Mouse events
                canvas.addEventListener('mousemove', handlePointerMove);
                canvas.addEventListener('mouseleave', hideCrosshair);
                
                // Touch events for mobile
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', hideCrosshair);
            });
        }
        
        function handlePointerMove(e) {
			const canvas = e.currentTarget.querySelector('canvas');
			if (!canvas) return;
			
			const chartId = canvas.id;
			const chart = charts[chartId];
			if (!chart) return;
			
			const rect = canvas.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			
			const canvasPosition = { x: x, y: y };

            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
            const index = Math.round(dataX);
            
            if (index >= 0 && index < chart.data.labels.length && globalHourlyData && globalHourlyData[index]) {
                updateCrosshair(index, canvasPosition.x);
            }
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            handleTouchMove(e);
        }
        
        function handleTouchMove(e) {
			e.preventDefault();
			const touch = e.touches[0];
			const canvas = e.currentTarget.querySelector('canvas');
			if (!canvas) return;
			
			const rect = canvas.getBoundingClientRect();
			const x = touch.clientX - rect.left;
			
			const chartId = canvas.id;
			const chart = charts[chartId];

            if (!chart) return;
            
            // Create a fake mouse event for Chart.js helper
            const fakeEvent = {
                native: touch,
                x: x,
                y: touch.clientY - rect.top
            };
            
            const canvasPosition = Chart.helpers.getRelativePosition(fakeEvent, chart);
            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
            const index = Math.round(dataX);
            
            if (index >= 0 && index < chart.data.labels.length && globalHourlyData && globalHourlyData[index]) {
                updateCrosshair(index, canvasPosition.x);
            }
        }
        
        function updateCrosshair(index, mouseX) {
            const crosshairLine = document.getElementById('crosshairLine');
            const crosshairTime = document.getElementById('crosshairTime');
            
            crosshairLine.style.left = `${mouseX + 3}px`;
            crosshairLine.style.display = 'block';
            
			if (globalHourlyData && globalHourlyData[index]) {
				const date = globalHourlyData[index].time;
				const now = new Date();
				const isHistorical = date < now;
				
				const dayStr = date.toLocaleDateString('en-US', { weekday: 'short' });
				const hour = date.getHours();
				const timeStr = hour === 0 ? '12 AM' : hour === 12 ? '12 PM' : hour > 12 ? `${hour - 12} PM` : `${hour} AM`;
				
				crosshairTime.innerHTML = `${isHistorical ? '(Past)' : dayStr}<br>${timeStr}`;
				crosshairTime.style.display = 'block';
			}
            
            updateTooltipForChart('tempChart', 'tempTooltip', index, mouseX);
            updateTooltipForChart('combinedChart', 'combinedTooltip', index, mouseX);
            updateTooltipForChart('precipAmountChart', 'precipTooltip', index, mouseX);
            updateTooltipForChart('windChart', 'windTooltip', index, mouseX);
        }
        
        function updateTooltipForChart(chartId, tooltipId, index, mouseX) {
            const chart = charts[chartId];
            const tooltip = document.getElementById(tooltipId);
            
            if (!chart || !tooltip) return;
            
            const datasets = chart.data.datasets;
            
            // Create array of label-value pairs with their actual values for sorting
            let dataItems = [];
            datasets.forEach(dataset => {
                const value = dataset.data[index];
                if (value !== null && value !== undefined) {
                    dataItems.push({
                        label: dataset.label,
                        value: value,
                        formattedValue: formatValue(value, chartId)
                    });
                }
            });
            
            // Sort by value descending (highest first)
            dataItems.sort((a, b) => b.value - a.value);
            
            // Create tooltip text from sorted items
            const values = dataItems.map(item => `${item.label}: ${item.formattedValue}`);
            
            if (values.length > 0) {
                tooltip.innerHTML = values.join('<br>');
                tooltip.style.left = `${mouseX + 15}px`;
                
                // Position tooltip based on first dataset's value
                const yPos = chart.scales.y.getPixelForValue(datasets[0].data[index]);
                tooltip.style.top = `${yPos - 10}px`;
                tooltip.style.display = 'block';
            }
        }
        
        function formatValue(value, chartId) {
            if (chartId === 'tempChart') return `${Math.round(value)}Â°F`;
            if (chartId === 'combinedChart') return `${Math.round(value)}%`;
            if (chartId === 'precipAmountChart') return `${value.toFixed(2)}"`;
            if (chartId === 'windChart') return `${Math.round(value)} mph`;
            return value;
        }
        
        function hideCrosshair() {
            document.getElementById('crosshairLine').style.display = 'none';
            document.querySelectorAll('.chart-value-tooltip').forEach(tooltip => {
                tooltip.style.display = 'none';
            });
        }
 
		function hexToRgba(hex, alpha = 1) {
			// Remove the # if present
			hex = hex.replace(/^#/, '');

			// Handle short form like #FFF
			if (hex.length === 3) {
				hex = hex.split('').map(c => c + c).join('');
			}

			const r = parseInt(hex.substring(0, 2), 16);
			const g = parseInt(hex.substring(2, 4), 16);
			const b = parseInt(hex.substring(4, 6), 16);

			return `rgba(${r}, ${g}, ${b}, ${alpha})`;
		}
 
        function createCharts(hourlyData) {
			globalHourlyData = hourlyData;
			
			// Calculate nowIndex once at the beginning
			const now = new Date();
			let nowIndex = -1;
			hourlyData.forEach((hour, index) => {
				if (nowIndex === -1 && hour.time >= now) {
					nowIndex = index;
				}
			});
	
			const nightAnnotations = getNightAnnotations(hourlyData);
			
			// Add "now" line annotation
			const nowLineAnnotation = nowIndex > 0 ? [{
				type: 'line',
				xMin: nowIndex - 0.5,
				xMax: nowIndex - 0.5,
				borderColor: 'rgba(0, 0, 0, .8)',
				borderWidth: 1,
				label: {
					content: 'Now',
					enabled: true,
					position: 'start',
					font: { size: 9 },
					backgroundColor: 'rgba(255, 0, 0, 0.1)',
					color: 'rgba(255, 0, 0, 0.8)'
				}
			}] : [];
			
            // Use the global day boundaries for alignment
            const dayLineAnnotations = globalDayBoundaries.slice(1).map(boundary => ({
                type: 'line',
                xMin: boundary - 0.5,
                xMax: boundary - 0.5,
                borderColor: 'rgba(0, 0, 0, 0.15)',
                borderWidth: 1,
                borderDash: [4, 2]
            }));
            
			const allAnnotations = [...nightAnnotations, ...dayLineAnnotations, ...nowLineAnnotation];            
            const labels = hourlyData.map(() => '');
            
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    },
                    annotation: {
                        annotations: allAnnotations
                    }
                },
				scales: {
					x: {
						grid: {
							display: false
						},
						ticks: {
							display: false
						}
					},
					y: {
						afterFit: (scaleInstance) => {
							scaleInstance.width = 45; // Set fixed width for all y-axes
						}
					}
				}
			};
            
            // Temperature Chart
            charts['tempChart'] = new Chart(document.getElementById('tempChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Temp',
                        data: hourlyData.map(h => h.temperature),
                        borderColor: '#ef4444',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
						segment: {
							borderColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('ef4444',0.5) : hexToRgba('ef4444',1);
							},
							backgroundColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('ef4444',0.05) : hexToRgba('ef4444',0.1);
							}
						}
                    }, {
                        label: 'Feels',
                        data: hourlyData.map(h => h.feelsLike),
                        borderColor: '#AC54A0',
                        borderDash: [3, 3],
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
						segment: {
							borderColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('AC54A0',0.5) : hexToRgba('AC54A0',1);
							}
						}
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
							...commonOptions.scales.y,
                           grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value + 'Â°',
                                font: { size: 9 }
                            }
                        }
                    }
                }
            });
            
            // Combined Chart
            charts['combinedChart'] = new Chart(document.getElementById('combinedChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Humidity',
                        data: hourlyData.map(h => h.humidity),
                        borderColor: '#90D104',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
						segment: {
							borderColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('90D104',0.5) : hexToRgba('90D104',1);
							}
						}
                    }, {
                        label: 'Clouds',
                        data: hourlyData.map(h => h.cloudCover),
                        borderColor: '#6b7280',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
						segment: {
							borderColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('6b7280',0.5) : hexToRgba('6b7280',1);
							},
							backgroundColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('6b7280',0.05) : hexToRgba('6b7280',0.2);
							}
						}
                    }, {
                        label: 'Precip',
                        data: hourlyData.map(h => h.precipProbability),
                        borderColor: '#3b82f6',
                       fill: true,
                        tension: 0.4,
                        pointRadius: 0,
						segment: {
							borderColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('3b82f6',0.5) : hexToRgba('3b82f6',1);
							},
							backgroundColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('3b82f6',0.05) : hexToRgba('3b82f6',0.2);
							}
						}
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
							...commonOptions.scales.y,
                           grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value + '%',
                                font: { size: 9 }
                            },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
            
            // Precipitation Amount Chart
            charts['precipAmountChart'] = new Chart(document.getElementById('precipAmountChart'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Precip Amount',
                        data: hourlyData.map(h => h.precipAmount),
                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                        borderColor: '#3b82f6',
                        borderWidth: 1
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
 							...commonOptions.scales.y,
                           grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value.toFixed(2) + '"',
                                font: { size: 9 }
                            },
                            min: 0
                        }
                    }
                }
            });
            
            // Wind Chart
            const windSpeeds = hourlyData.map(h => h.windSpeed);
            const windGusts = hourlyData.map(h => h.windGust);
            const maxWind = Math.max(
                ...windSpeeds,
                ...windGusts.filter(g => g !== null)
            );
            const yMax = Math.ceil(maxWind / 5) * 5 + 5;
            
            charts['windChart'] = new Chart(document.getElementById('windChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Gusts',
                        data: windGusts,
                        borderColor: '#D65011',
                        borderDash: [2, 2],
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
                        spanGaps: true,
						segment: {
							borderColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('D65011',0.5) : hexToRgba('D65011',1);
							}
						}
                    }, {
                        label: 'Speed',
                        data: windSpeeds,
                        borderColor: '#B58635',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0,
						segment: {
							borderColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('B58635',0.5) : hexToRgba('B58635',1);
							},
							backgroundColor: (ctx) => {
								return ctx.p0DataIndex < nowIndex ? hexToRgba('B58635',0.05) : hexToRgba('B58635',0.2);
							}
						}
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
							...commonOptions.scales.y,
                            grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value + ' mph',
                                font: { size: 9 },
                                stepSize: 5
                            },
                            min: 0,
                            max: yMax
                        }
                    }
                }
            });
            
            setTimeout(setupCrosshair, 100);
        }
        
		// URL Parameter Functions
		function getLocationFromURL() {
			const params = new URLSearchParams(window.location.search);
			const lat = params.get('lat');
			const lon = params.get('lon');
			const name = params.get('name');
			
			if (lat && lon) {
				const latitude = parseFloat(lat);
				const longitude = parseFloat(lon);
				
				// Validate coordinates
				if (!isNaN(latitude) && !isNaN(longitude) && 
					latitude >= -90 && latitude <= 90 && 
					longitude >= -180 && longitude <= 180) {
					
					return {
						lat: latitude,
						lon: longitude,
						name: name ? decodeURIComponent(name) : null
					};
				}
			}
			
			return null;
		}

		function updateURL(lat, lon, locationName) {
			const params = new URLSearchParams();
			params.set('lat', lat.toFixed(4));
			params.set('lon', lon.toFixed(4));
			
			if (locationName) {
				params.set('name', encodeURIComponent(locationName));
			}
			
			// Update URL without reloading the page
			const newURL = window.location.pathname + '?' + params.toString();
			window.history.replaceState({ lat, lon, name: locationName }, '', newURL);
		}

        // Function to get user's GPS location
        function useMyLocation() {
            if (navigator.geolocation) {
                // Show loading state
                document.getElementById('locationName').textContent = 'Getting location...';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('chartsContainer').style.display = 'none';
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        // Success! We got the location
                        currentLat = position.coords.latitude;
                        currentLon = position.coords.longitude;
                        
                        console.log('GPS Location obtained:', currentLat, currentLon);
                        
                        // Get location name from coordinates
                        reverseGeocode(currentLat, currentLon);
                        
                        // Reset elevation for new location
                        currentElevation = null;
                        
                        // Destroy existing charts
                        Object.values(charts).forEach(chart => {
                            if (chart) chart.destroy();
                        });
                        charts = {};
                        
                        // Reinitialize with new location
                        initializeForecast();
                    },
                    (error) => {
                        // Handle errors
                        let errorMessage = 'Could not get your location. ';
                        
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage += 'Please allow location access and try again.';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage += 'Location information is unavailable.';
                                break;
                            case error.TIMEOUT:
                                errorMessage += 'Location request timed out.';
                                break;
                            default:
                                errorMessage += 'An unknown error occurred.';
                        }
                        
                        alert(errorMessage);
                        console.error('Geolocation error:', error);
                        
                        // Restore previous location name
                        document.getElementById('locationName').textContent = currentLocationName;
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('chartsContainer').style.display = 'block';
                    },
                    {
                        enableHighAccuracy: true,  // Use GPS if available
                        timeout: 10000,            // Wait up to 10 seconds
                        maximumAge: 0              // Don't use cached location
                    }
                );
            } else {
                alert('Geolocation is not supported by your browser.');
            }
        }


        // Initialize with URL parameters or default location
        function initializeApp() {
            const urlLocation = getLocationFromURL();
            
            if (urlLocation) {
                // Use location from URL
                currentLat = urlLocation.lat;
                currentLon = urlLocation.lon;
                
                if (urlLocation.name) {
                    currentLocationName = urlLocation.name;
                    document.getElementById('locationName').textContent = currentLocationName;
                } else {
                    // If no name provided, reverse geocode to get the name
                    reverseGeocode(currentLat, currentLon);
                }
            } else {
                // No URL parameters, use default location and update URL
                updateURL(currentLat, currentLon, currentLocationName);
            }
            
            initializeForecast();
        }

        // Reverse geocoding function
        async function reverseGeocode(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
                const data = await response.json();
                
                if (data && data.display_name) {
                    currentLocationName = data.display_name.split(',').slice(0, 2).join(', ');
                    document.getElementById('locationName').textContent = currentLocationName;
                    updateURL(lat, lon, currentLocationName);
                }
            } catch (error) {
                console.error('Reverse geocoding error:', error);
                currentLocationName = `${lat.toFixed(4)}Â°, ${lon.toFixed(4)}Â°`;
                document.getElementById('locationName').textContent = currentLocationName;
            }
        }

        // Handle browser back/forward buttons
        window.addEventListener('popstate', (event) => {
            if (event.state && event.state.lat && event.state.lon) {
                currentLat = event.state.lat;
                currentLon = event.state.lon;
                currentLocationName = event.state.name || `${currentLat.toFixed(4)}Â°, ${currentLon.toFixed(4)}Â°`;
                document.getElementById('locationName').textContent = currentLocationName;
                
                // Destroy existing charts before reinitializing
                Object.values(charts).forEach(chart => {
                    if (chart) chart.destroy();
                });
                charts = {};
                
                initializeForecast();
            }
        });


        async function initializeForecast() {
            try {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('chartsContainer').style.display = 'none';
                document.getElementById('currentConditions').innerHTML = '<div class="loading">Loading...</div>';
                
                const data = await getForecastData();
                
                updateLocationDetails();
                
                const now = new Date();
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })}`;
                
                const hourlyData = processGriddedDataToHourly(data.gridded);
                
                createCurrentConditions(hourlyData);
                createDetailedForcast(data.daily);
                createDailyForecast(data.daily, hourlyData);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('chartsContainer').style.display = 'block';
                
                createCharts(hourlyData);
                
            } catch (error) {
                console.error("Failed to initialize forecast:", error);
            }
        }
        
                // NEW:
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            // DOM is already loaded
            initializeApp();
        }
        setInterval(initializeForecast, 30 * 60 * 1000);
    </script>

</body>
</html>
