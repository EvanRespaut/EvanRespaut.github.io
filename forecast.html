<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Forecast</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: #f0f2f5;
            padding: 20px;
        }
        
        .main-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left {
            flex: 1;
        }
        
        .header-left h1 {
            font-size: 20px;
            margin-bottom: 3px;
        }
        
        .header-left .subtitle {
            opacity: 0.9;
            font-size: 11px;
            margin-top: 3px;
        }
        
        /* Location Search */
        .location-search {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 20px;
            transition: background 0.2s;
        }
        
        .location-search:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .location-search input {
            background: transparent;
            border: none;
            color: white;
            outline: none;
            width: 150px;
            font-size: 13px;
        }
        
        .location-search input::placeholder {
            color: rgba(255, 255, 255, 0.8);
        }
        
        .location-search button {
            background: rgba(255, 255, 255, 0.3);
            border: none;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .location-search button:hover {
            background: rgba(255, 255, 255, 0.4);
        }
        
        .last-updated {
            font-size: 11px;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        /* Current Conditions */
        .current-conditions {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 20px;
            overflow-x: auto;
        }
        
        .current-temp {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-right: 20px;
            border-right: 1px solid #e0e0e0;
            min-width: 120px;
        }
        
        .current-temp-value {
            font-size: 45px;
            font-weight: 300;
            line-height: 1;
        }
        
        .current-temp-feels {
            font-size: 15px;
            color: #666;
        }
        
        .current-condition-icon {
            font-size: 32px;
        }
        
        .current-stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .current-stat {
            display: flex;
            flex-direction: column;
            min-width: 60px;
        }
        
        .current-stat-value {
            font-size: 22px;
            font-weight: 500;
            color: #333;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .current-stat-label {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
                
        .wind-arrow {
            display: inline-block;
            font-size: 18px;
            transform-origin: center;
        }
		
        /* Current Forecast Section */
        .current-forecast {
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            padding: 10px 20px;
        }
        
        .forecast-period {
            margin-bottom: 12px;
        }
        
        .forecast-period:last-child {
            margin-bottom: 0;
        }
        
        .forecast-period-title {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .forecast-period-text {
            font-size: 13px;
            color: #555;
            line-height: 1.4;
        }
        
        /* Daily Forecast Strip */
        .daily-forecast {
            background: #fff;
            border-bottom: 2px solid #e0e0e0;
            position: relative;
            overflow-x: auto;
            padding: 0 15px;
        }
        
        .daily-forecast-container {
            display: flex;
            position: relative;
            min-height: 150px;
        }
        
        .day-forecast {
            background: white;
            border-right: 1px solid #e0e0e0;
            padding: 10px 5px;
            text-align: center;
            transition: background-color 0.2s;
            position: relative;
            cursor: pointer;
            display: flex;
            flex-direction: column;
        }
        
        .day-forecast:last-child {
            border-right: none;
        }
        
        .day-forecast:hover {
            background-color: #f0f9ff;
        }
        
        .day-name {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .day-icon {
            font-size: 30px;
            margin: 5px 0;
        }
        
        .day-temps {
            display: flex;
            justify-content: center;
            gap: 8px;
            font-size: 18px;
            margin-bottom: 5px;
        }
        
        .day-high {
            font-weight: 600;
            color: #ef4444;
        }
        
        .day-low {
            color: #3b82f6;
        }
        
        .day-detail {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
            padding: 0 5px;
            line-height: 1.3;
            flex-grow: 1;
            display: flex;
            align-items: center;
            text-align: left;
        }
        
        /* Charts */
        .charts-wrapper {
            padding: 15px;
            background: #fafafa;
            position: relative;
            overflow-x: auto;
        }
        
        .chart-section {
            margin-bottom: 12px;
            position: relative;
        }
        
        .chart-container {
            position: relative;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 20px 10px 10px 10px;
            overflow: hidden;
        }
        
        .chart-container.temperature-chart {
            height: 150px;
        }
        
        .chart-container.combined-chart {
            height: 130px;
        }
        
        .chart-container.precipitation-amount-chart {
            height: 100px;
        }
        
        .chart-container.wind-chart {
            height: 120px;
        }
        
        .chart-label {
            position: absolute;
            left: 10px;
            top: 5px;
            font-size: 10px;
            font-weight: 600;
            color: #666;
            z-index: 10;
        }
        
        /* Crosshair tooltip */
        .crosshair-line {
            position: absolute;
            width: 1px;
            background: rgba(0, 0, 0, 0.3);
            pointer-events: none;
            top: 0;
            bottom: 0;
            display: none;
            z-index: 1000;
        }
        
        .crosshair-time {
            position: absolute;
            top: -20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            transform: translateX(-50%);
            white-space: nowrap;
        }
        
        .chart-value-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
            white-space: nowrap;
            z-index: 1001;
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            text-align: center;
            padding: 40px;
            color: #d32f2f;
        }

        canvas {
            max-height: 100%;
            cursor: crosshair;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2"></script>
</head>
<body>

    <div class="main-container">
        <div class="header">
            <div class="header-left">
                <h1>üìç <span id="locationName">Tysons, Virginia</span></h1>
                <div class="subtitle" id="locationDetails">Loading...</div>
                <div class="last-updated" id="lastUpdated">Last updated: --</div>
            </div>
            <div class="location-search">
                <input type="text" id="locationInput" placeholder="Search location..." />
                <button onclick="searchLocation()">Go</button>
            </div>
        </div>
        
        <!-- Current Conditions -->
        <div class="current-conditions" id="currentConditions">
            <div class="loading">Loading current conditions...</div>
        </div>
        
        <!-- Current Forecast Details -->
        <div class="current-forecast" id="currentForecast" style="display: none;">
            <!-- Detailed forecast will be inserted here -->
        </div>
        
        <!-- Daily Forecast Strip -->
        <div class="daily-forecast">
            <div class="daily-forecast-container" id="dailyForecast">
                <!-- Daily forecasts will be inserted here -->
            </div>
        </div>
        
        <!-- Charts -->
        <div class="charts-wrapper">
            <div class="loading" id="loading">Loading forecast data...</div>
            <div id="chartsContainer" style="display: none;">
                <!-- Crosshair line that spans all charts -->
                <div class="crosshair-line" id="crosshairLine">
                    <div class="crosshair-time" id="crosshairTime"></div>
                </div>
                
                <!-- Temperature Chart -->
                <div class="chart-section">
                    <div class="chart-label">TEMPERATURE & FEELS LIKE</div>
                    <div class="chart-container temperature-chart">
                        <canvas id="tempChart"></canvas>
                        <div class="chart-value-tooltip" id="tempTooltip"></div>
                    </div>
                </div>
                
                <!-- Combined Chart -->
                <div class="chart-section">
                    <div class="chart-label">HUMIDITY, CLOUD COVER & PRECIPITATION</div>
                    <div class="chart-container combined-chart">
                        <canvas id="combinedChart"></canvas>
                        <div class="chart-value-tooltip" id="combinedTooltip"></div>
                    </div>
                </div>
                
                <!-- Precipitation Amount Chart -->
                <div class="chart-section">
                    <div class="chart-label">PRECIPITATION AMOUNT</div>
                    <div class="chart-container precipitation-amount-chart">
                        <canvas id="precipAmountChart"></canvas>
                        <div class="chart-value-tooltip" id="precipTooltip"></div>
                    </div>
                </div>
                
                <!-- Wind Chart -->
                <div class="chart-section">
                    <div class="chart-label">WIND SPEED & GUSTS</div>
                    <div class="chart-container wind-chart">
                        <canvas id="windChart"></canvas>
                        <div class="chart-value-tooltip" id="windTooltip"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let charts = {};
        let currentLat = 38.92;
        let currentLon = -77.23;
        let currentLocationName = "Tysons, Virginia";
        let currentElevation = null;
        let globalHourlyData = null;
        let globalDayBoundaries = [];
        
        // Chart configuration defaults
        Chart.defaults.font.size = 10;
        Chart.defaults.font.family = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, sans-serif';
        
        // Register annotation plugin
        Chart.register(window['chartjs-plugin-annotation']);
        
        // Location search function
        async function searchLocation() {
            const input = document.getElementById('locationInput').value.trim();
            if (!input) return;
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(input)}&limit=1`);
                const data = await response.json();
                
                if (data && data.length > 0) {
                    const location = data[0];
                    currentLat = parseFloat(location.lat);
                    currentLon = parseFloat(location.lon);
                    currentLocationName = location.display_name.split(',').slice(0, 2).join(', ');
                    document.getElementById('locationName').textContent = currentLocationName;
                    
                    // Reset elevation when changing locations
                    currentElevation = null;
                    
                    // Destroy existing charts before reinitializing
                    Object.values(charts).forEach(chart => {
                        if (chart) chart.destroy();
                    });
                    charts = {};
                    
                    document.getElementById('locationInput').value = '';
                    initializeForecast();
                } else {
                    alert('Location not found. Please try another search.');
                }
            } catch (error) {
                console.error('Geocoding error:', error);
                alert('Error searching for location. Please try again.');
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('locationInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    searchLocation();
                }
            });
        });
        
        // Update location details
        function updateLocationDetails() {
            const elevText = currentElevation !== null && currentElevation !== undefined ? 
                `${Math.round(currentElevation * 3.28084)} ft` : '';
            const coordsText = `${currentLat.toFixed(4)}¬∞, ${currentLon.toFixed(4)}¬∞`;
            document.getElementById('locationDetails').textContent = `${coordsText}${elevText ? ' ‚Ä¢ ' + elevText : ''}`;
        }
        
        // Utility functions
        function parseValidTime(validTimeStr) {
            const [timeStr, durationStr] = validTimeStr.split('/');
            const startTime = new Date(timeStr);
            
            let durationHours = 1;
            if (durationStr) {
                const durationMatch = durationStr.match(/PT(\d+)H/);
                if (durationMatch) {
                    durationHours = parseInt(durationMatch[1]);
                }
            }
            
            const endTime = new Date(startTime.getTime() + durationHours * 3600000);
            
            return { startTime, endTime, durationHours };
        }
        
        function getValueAtTime(values, targetTime) {
            if (!values || !values.length) return null;
            
            const targetDate = new Date(targetTime);
            
            for (const item of values) {
                const { startTime, endTime } = parseValidTime(item.validTime);
                if (targetDate >= startTime && targetDate < endTime) {
                    return item.value;
                }
            }
            
            return null;
        }
        
        function calculateFeelsLike(temp, humidity, windSpeed) {
            if (temp <= 50 && windSpeed > 3) {
                return Math.round(35.74 + 0.6215 * temp - 35.75 * Math.pow(windSpeed, 0.16) + 0.4275 * temp * Math.pow(windSpeed, 0.16));
            } else if (temp >= 80) {
                const c1 = -42.379, c2 = 2.04901523, c3 = 10.14333127;
                const c4 = -0.22475541, c5 = -0.00683783, c6 = -0.05481717;
                const c7 = 0.00122874, c8 = 0.00085282, c9 = -0.00000199;
                
                let heatIndex = c1 + c2*temp + c3*humidity + c4*temp*humidity + c5*temp*temp + 
                               c6*humidity*humidity + c7*temp*temp*humidity + c8*temp*humidity*humidity + 
                               c9*temp*temp*humidity*humidity;
                return Math.round(heatIndex);
            }
            return Math.round(temp);
        }
        
        function getWeatherIcon(conditions) {
            if (!conditions) return '‚òÅÔ∏è';
            
            if (Array.isArray(conditions) && conditions.length > 0) {
                const primary = conditions[0].weather?.toLowerCase() || '';
                if (primary.includes('thunder')) return '‚õàÔ∏è';
                if (primary.includes('rain') || primary.includes('shower')) return 'üåßÔ∏è';
                if (primary.includes('snow')) return '‚ùÑÔ∏è';
                if (primary.includes('fog')) return 'üå´Ô∏è';
            }
            
            const forecast = conditions.toLowerCase();
            if (forecast.includes('sunny') || forecast.includes('clear')) return '‚òÄÔ∏è';
            if (forecast.includes('partly')) return '‚õÖ';
            if (forecast.includes('cloudy')) return '‚òÅÔ∏è';
            if (forecast.includes('rain') || forecast.includes('shower')) return 'üåßÔ∏è';
            if (forecast.includes('storm')) return '‚õàÔ∏è';
            if (forecast.includes('snow')) return '‚ùÑÔ∏è';
            if (forecast.includes('fog')) return 'üå´Ô∏è';
            if (forecast.includes('wind')) return 'üí®';
            return '‚òÅÔ∏è';
        }
        
        function getWeatherDescription(cloudCover, precipProb, temp) {
            if (precipProb > 60) return 'Rainy';
            if (precipProb > 30) return 'Chance of Rain';
            if (cloudCover < 20) return 'Clear';
            if (cloudCover < 50) return 'Partly Cloudy';
            if (cloudCover < 80) return 'Mostly Cloudy';
            return 'Cloudy';
        }
        
        function getWindArrow(degrees) {
            if (degrees === null || degrees === undefined) return '';
            const rotation = degrees;
            return '<span class="wind-arrow" style="transform: rotate(' + rotation + 'deg);">‚Üì</span>';
        }
        
        function getSunTimes(date, lat, lon) {
            const dayOfYear = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
            const P = Math.asin(0.39795 * Math.cos(0.98563 * (dayOfYear - 173) * Math.PI / 180));
            const sunrise = -Math.tan(lat * Math.PI / 180) * Math.tan(P);
            
            if (sunrise < -1) return { sunrise: 0, sunset: 24 };
            else if (sunrise > 1) return { sunrise: 12, sunset: 12 };
            
            const hourAngle = Math.acos(sunrise) * 180 / Math.PI;
            const sunriseTime = 12 - hourAngle / 15 - lon / 15 - date.getTimezoneOffset() / 60;
            const sunsetTime = 12 + hourAngle / 15 - lon / 15 - date.getTimezoneOffset() / 60;
            
            const B = 2 * Math.PI * (dayOfYear - 81) / 365;
            const E = 9.87 * Math.sin(2 * B) - 7.53 * Math.cos(B) - 1.5 * Math.sin(B);
            
            return {
                sunrise: sunriseTime - E / 60,
                sunset: sunsetTime - E / 60
            };
        }
        
        async function getForecastData() {
            try {
                const gridResponse = await fetch(`https://api.weather.gov/points/${currentLat},${currentLon}`);
                if (!gridResponse.ok) throw new Error(`Grid API Error: ${gridResponse.status}`);
                const gridData = await gridResponse.json();
                
                // Get elevation from grid data
                if (gridData.properties && gridData.properties.elevation && gridData.properties.elevation.value !== undefined) {
                    currentElevation = gridData.properties.elevation.value;
                    console.log('Elevation found:', currentElevation);
                }
                
                const gridForecastResponse = await fetch(gridData.properties.forecastGridData);
                if (!gridForecastResponse.ok) throw new Error(`Grid Forecast Error: ${gridForecastResponse.status}`);
                const gridForecastData = await gridForecastResponse.json();
                
                const dailyResponse = await fetch(gridData.properties.forecast);
                if (!dailyResponse.ok) throw new Error(`Daily Forecast Error: ${dailyResponse.status}`);
                const dailyData = await dailyResponse.json();
                
                return {
                    gridded: gridForecastData.properties,
                    daily: dailyData.properties.periods
                };
            } catch (error) {
                console.error("Error fetching forecast data:", error);
                document.getElementById('loading').innerHTML = `<div class="error">Error loading forecast: ${error.message}</div>`;
                throw error;
            }
        }
        
        function processGriddedDataToHourly(gridded) {
            const now = new Date();
            const startHour = new Date(now);
            startHour.setMinutes(0, 0, 0);
            
            const hourlyData = [];
            
            for (let i = 0; i < 168; i++) {
                const hourTime = new Date(startHour.getTime() + i * 3600000);
                
                const tempC = getValueAtTime(gridded.temperature?.values, hourTime);
                const tempF = tempC !== null ? Math.round(tempC * 9/5 + 32) : null;
                
                const windSpeedKmh = getValueAtTime(gridded.windSpeed?.values, hourTime);
                const windSpeedMph = windSpeedKmh !== null ? Math.round(windSpeedKmh * 0.621371) : 0;
                
                const windGustKmh = getValueAtTime(gridded.windGust?.values, hourTime);
                const windGustMph = windGustKmh !== null && windGustKmh > 0 ? Math.round(windGustKmh * 0.621371) : null;
                
                const windDirection = getValueAtTime(gridded.windDirection?.values, hourTime);
                const windDirStr = windDirection !== null ?
                    ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'][Math.round(windDirection / 22.5) % 16] : '';
                
                const humidity = getValueAtTime(gridded.relativeHumidity?.values, hourTime) || 50;
                const cloudCover = getValueAtTime(gridded.skyCover?.values, hourTime) || 0;
                const precipProbability = getValueAtTime(gridded.probabilityOfPrecipitation?.values, hourTime) || 0;
                const precipAmountMm = getValueAtTime(gridded.quantitativePrecipitation?.values, hourTime) || 0;
                const precipAmountIn = precipAmountMm * 0.0393701;
                
                const apparentTempC = getValueAtTime(gridded.apparentTemperature?.values, hourTime);
                const feelsLike = apparentTempC !== null ? 
                    Math.round(apparentTempC * 9/5 + 32) : 
                    (tempF !== null ? calculateFeelsLike(tempF, humidity, windSpeedMph) : null);
                
                const weather = getValueAtTime(gridded.weather?.values, hourTime);
                
                hourlyData.push({
                    time: hourTime,
                    temperature: tempF,
                    feelsLike: feelsLike,
                    windSpeed: windSpeedMph,
                    windGust: windGustMph,
                    windDirection: windDirStr,
                    windDegrees: windDirection,
                    humidity: Math.round(humidity),
                    cloudCover: Math.round(cloudCover),
                    precipProbability: Math.round(precipProbability),
                    precipAmount: precipAmountIn,
                    weather: weather,
                    description: getWeatherDescription(cloudCover, precipProbability, tempF)
                });
            }
            
            return hourlyData.filter(h => h.temperature !== null);
        }
        
        function createCurrentConditions(hourlyData) {
            if (!hourlyData || hourlyData.length === 0) {
                document.getElementById('currentConditions').innerHTML = '<div style="padding: 15px; color: #666;">Current conditions unavailable</div>';
                return;
            }
            
            const current = hourlyData[0];
            
            const html = `
                <div class="current-temp">
                    <div>
                        <div class="current-temp-value">${current.temperature}¬∞</div>
                        <div class="current-temp-feels">Feels ${current.feelsLike}¬∞</div>
                    </div>
                    <div class="current-condition-icon">${getWeatherIcon(current.description)}</div>
                </div>
                <div class="current-stats">
                    <div class="current-stat">
                        <div class="current-stat-value">
                            ${getWindArrow(current.windDegrees)}
                            ${current.windSpeed}
                        </div>
                        <div class="current-stat-label">Wind ${current.windDirection} mph</div>
                    </div>
                    ${current.windGust ? `
                        <div class="current-stat">
                            <div class="current-stat-value">${current.windGust}</div>
                            <div class="current-stat-label">Gusts mph</div>
                        </div>
                    ` : ''}
                    <div class="current-stat">
                        <div class="current-stat-value">${current.humidity}%</div>
                        <div class="current-stat-label">Humidity</div>
                    </div>
                </div>
            `;
            
            document.getElementById('currentConditions').innerHTML = html;
        }
        
        function createCurrentForecast(dailyPeriods) {
            const now = new Date();
            const currentHour = now.getHours();
            
            // Between 5pm (17) and 6am (6), show Tonight and Tomorrow
            const showTonightTomorrow = currentHour >= 17 || currentHour < 6;
            
            let firstPeriod = null;
            let secondPeriod = null;
            let firstTitle = '';
            let secondTitle = '';
            
            if (showTonightTomorrow) {
                // Find tonight and tomorrow
                for (let i = 0; i < dailyPeriods.length; i++) {
                    const period = dailyPeriods[i];
                    if (!firstPeriod && !period.isDaytime) {
                        firstPeriod = period;
                        firstTitle = 'Tonight';
                    } else if (firstPeriod && !secondPeriod && period.isDaytime) {
                        secondPeriod = period;
                        secondTitle = 'Tomorrow';
                        break;
                    }
                }
            } else {
                // Find today and tonight
                for (let i = 0; i < dailyPeriods.length; i++) {
                    const period = dailyPeriods[i];
                    if (!firstPeriod && period.isDaytime) {
                        firstPeriod = period;
                        firstTitle = 'Today';
                    } else if (firstPeriod && !secondPeriod && !period.isDaytime) {
                        secondPeriod = period;
                        secondTitle = 'Tonight';
                        break;
                    }
                }
            }
            
            if (!firstPeriod && !secondPeriod) {
                document.getElementById('currentForecast').style.display = 'none';
                return;
            }
            
            let html = '';
            
            if (firstPeriod) {
                html += `
                    <div class="forecast-period">
                        <div class="forecast-period-title">${firstTitle}</div>
                        <div class="forecast-period-text">${firstPeriod.detailedForecast}</div>
                    </div>
                `;
            }
            
            if (secondPeriod) {
                html += `
                    <div class="forecast-period">
                        <div class="forecast-period-title">${secondTitle}</div>
                        <div class="forecast-period-text">${secondPeriod.detailedForecast}</div>
                    </div>
                `;
            }
            
            document.getElementById('currentForecast').innerHTML = html;
            document.getElementById('currentForecast').style.display = 'block';
        }
        
        function createDailyForecast(dailyPeriods, hourlyData) {
            // Calculate day boundaries
            const boundaries = [];
            let currentDay = null;
            
            hourlyData.forEach((hour, index) => {
                const dayStr = hour.time.toDateString();
                if (dayStr !== currentDay) {
                    boundaries.push(index);
                    currentDay = dayStr;
                }
            });
            
            globalDayBoundaries = boundaries;
            
            // Create day groups based on boundaries
            const days = [];
            for (let i = 0; i < boundaries.length && i < 7; i++) {
                const startIdx = boundaries[i];
                const endIdx = boundaries[i + 1] || hourlyData.length;
                const dayHours = hourlyData.slice(startIdx, endIdx);
                
                if (dayHours.length > 0) {
                    const temps = dayHours.map(h => h.temperature).filter(t => t !== null);
                    const date = dayHours[0].time;
                    
                    // Find matching daily forecast
                    let dayPeriod = null;
                    for (const period of dailyPeriods) {
                        const periodDate = new Date(period.startTime);
                        if (periodDate.toDateString() === date.toDateString() && period.isDaytime) {
                            dayPeriod = period;
                            break;
                        }
                    }
                    
                    days.push({
                        date: date,
                        high: Math.max(...temps),
                        low: Math.min(...temps),
                        hoursCount: dayHours.length,
                        startIdx: startIdx,
                        endIdx: endIdx,
                        description: dayPeriod ? dayPeriod.shortForecast : dayHours[Math.floor(dayHours.length / 2)].description
                    });
                }
            }
            
            // Calculate total width for proper percentage
            const totalHours = hourlyData.length;
            
            const html = days.map(day => {
                const dayName = day.date.toLocaleDateString('en-US', { 
                    weekday: 'short', 
                    month: 'numeric',
                    day: 'numeric'
                });
                
                const widthPercent = (day.hoursCount / totalHours) * 100;
                
                return `
                    <div class="day-forecast" 
                         style="flex: 0 0 ${widthPercent}%;">
                        <div class="day-name">${dayName}</div>
                        <div class="day-icon">${getWeatherIcon(day.description)}</div>
                        <div class="day-temps">
                            <span class="day-high">${Math.round(day.high)}¬∞</span>
                            <span class="day-low">${Math.round(day.low)}¬∞</span>
                        </div>
                        <div class="day-detail">${day.description}</div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('dailyForecast').innerHTML = html;
        }
        
        function getNightAnnotations(hourlyData) {
            const annotations = [];
            let inNight = false;
            let nightStart = null;
            
            hourlyData.forEach((hour, index) => {
                const date = hour.time;
                const hourNum = date.getHours();
                const sunTimes = getSunTimes(date, currentLat, currentLon);
                
                const sunriseHour = Math.round(sunTimes.sunrise);
                const sunsetHour = Math.round(sunTimes.sunset);
                const isNight = hourNum < sunriseHour || hourNum >= sunsetHour;
                
                if (isNight && !inNight) {
                    nightStart = index;
                    inNight = true;
                } else if (!isNight && inNight) {
                    if (nightStart !== null) {
                        annotations.push({
                            type: 'box',
                            xMin: nightStart - 0.5,
                            xMax: index - 0.5,
                            backgroundColor: 'rgba(20, 20, 50, 0.04)',
                            borderWidth: 0
                        });
                    }
                    inNight = false;
                    nightStart = null;
                }
            });
            
            if (inNight && nightStart !== null) {
                annotations.push({
                    type: 'box',
                    xMin: nightStart - 0.5,
                    xMax: hourlyData.length - 0.5,
                    backgroundColor: 'rgba(20, 20, 50, 0.04)',
                    borderWidth: 0
                });
            }
            
            return annotations;
        }
        
        function setupCrosshair() {
            const chartsContainer = document.getElementById('chartsContainer');
            const canvases = chartsContainer.querySelectorAll('canvas');
            
            canvases.forEach(canvas => {
                canvas.addEventListener('mousemove', (e) => {
                    const chartId = canvas.id;
                    const chart = charts[chartId];
                    if (!chart) return;
                    
                    const canvasPosition = Chart.helpers.getRelativePosition(e, chart);
                    const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                    const index = Math.round(dataX);
                    
                    if (index >= 0 && index < chart.data.labels.length && globalHourlyData && globalHourlyData[index]) {
                        updateCrosshair(index, canvasPosition.x);
                    }
                });
                
                canvas.addEventListener('mouseleave', () => {
                    hideCrosshair();
                });
            });
        }
        
        function updateCrosshair(index, mouseX) {
            const crosshairLine = document.getElementById('crosshairLine');
            const crosshairTime = document.getElementById('crosshairTime');
            
            crosshairLine.style.left = `${mouseX + 25}px`;
            crosshairLine.style.display = 'block';
            
            if (globalHourlyData && globalHourlyData[index]) {
                const date = globalHourlyData[index].time;
                const hour = date.getHours();
                const timeStr = hour === 0 ? '12 AM' : hour === 12 ? '12 PM' : hour > 12 ? `${hour - 12} PM` : `${hour} AM`;
                crosshairTime.textContent = timeStr;
            }
            
            updateTooltipForChart('tempChart', 'tempTooltip', index, mouseX);
            updateTooltipForChart('combinedChart', 'combinedTooltip', index, mouseX);
            updateTooltipForChart('precipAmountChart', 'precipTooltip', index, mouseX);
            updateTooltipForChart('windChart', 'windTooltip', index, mouseX);
        }
        
        function updateTooltipForChart(chartId, tooltipId, index, mouseX) {
            const chart = charts[chartId];
            const tooltip = document.getElementById(tooltipId);
            
            if (!chart || !tooltip) return;
            
            const datasets = chart.data.datasets;
            
            // Create array of label-value pairs with their actual values for sorting
            let dataItems = [];
            datasets.forEach(dataset => {
                const value = dataset.data[index];
                if (value !== null && value !== undefined) {
                    dataItems.push({
                        label: dataset.label,
                        value: value,
                        formattedValue: formatValue(value, chartId)
                    });
                }
            });
            
            // Sort by value descending (highest first)
            dataItems.sort((a, b) => b.value - a.value);
            
            // Create tooltip text from sorted items
            const values = dataItems.map(item => `${item.label}: ${item.formattedValue}`);
            
            if (values.length > 0) {
                tooltip.innerHTML = values.join('<br>');
                tooltip.style.left = `${mouseX + 15}px`;
                
                // Position tooltip based on first dataset's value
                const yPos = chart.scales.y.getPixelForValue(datasets[0].data[index]);
                tooltip.style.top = `${yPos - 10}px`;
                tooltip.style.display = 'block';
            }
        }
        
        function formatValue(value, chartId) {
            if (chartId === 'tempChart') return `${Math.round(value)}¬∞F`;
            if (chartId === 'combinedChart') return `${Math.round(value)}%`;
            if (chartId === 'precipAmountChart') return `${value.toFixed(2)}"`;
            if (chartId === 'windChart') return `${Math.round(value)} mph`;
            return value;
        }
        
        function hideCrosshair() {
            document.getElementById('crosshairLine').style.display = 'none';
            document.querySelectorAll('.chart-value-tooltip').forEach(tooltip => {
                tooltip.style.display = 'none';
            });
        }
        
        function createCharts(hourlyData) {
            globalHourlyData = hourlyData;
            
            const nightAnnotations = getNightAnnotations(hourlyData);
            
            // Use the global day boundaries for alignment
            const dayLineAnnotations = globalDayBoundaries.slice(1).map(boundary => ({
                type: 'line',
                xMin: boundary - 0.5,
                xMax: boundary - 0.5,
                borderColor: 'rgba(0, 0, 0, 0.15)',
                borderWidth: 1,
                borderDash: [4, 2]
            }));
            
            const allAnnotations = [...nightAnnotations, ...dayLineAnnotations];
            
            const labels = hourlyData.map(() => '');
            
            const commonOptions = {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    },
                    annotation: {
                        annotations: allAnnotations
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            display: false
                        }
                    }
                }
            };
            
            // Temperature Chart
            charts['tempChart'] = new Chart(document.getElementById('tempChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Temperature',
                        data: hourlyData.map(h => h.temperature),
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }, {
                        label: 'Feels Like',
                        data: hourlyData.map(h => h.feelsLike),
                        borderColor: '#AC54A0',
                        borderDash: [3, 3],
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value + '¬∞',
                                font: { size: 9 }
                            }
                        }
                    }
                }
            });
            
            // Combined Chart
            charts['combinedChart'] = new Chart(document.getElementById('combinedChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Humidity',
                        data: hourlyData.map(h => h.humidity),
                        borderColor: '#90D104',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }, {
                        label: 'Cloud Cover',
                        data: hourlyData.map(h => h.cloudCover),
                        borderColor: '#6b7280',
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }, {
                        label: 'Precip Chance',
                        data: hourlyData.map(h => h.precipProbability),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value + '%',
                                font: { size: 9 }
                            },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
            
            // Precipitation Amount Chart
            charts['precipAmountChart'] = new Chart(document.getElementById('precipAmountChart'), {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Precip Amount',
                        data: hourlyData.map(h => h.precipAmount),
                        backgroundColor: 'rgba(59, 130, 246, 0.6)',
                        borderColor: '#3b82f6',
                        borderWidth: 1
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value.toFixed(2) + '"',
                                font: { size: 9 }
                            },
                            min: 0
                        }
                    }
                }
            });
            
            // Wind Chart
            const windSpeeds = hourlyData.map(h => h.windSpeed);
            const windGusts = hourlyData.map(h => h.windGust);
            const maxWind = Math.max(
                ...windSpeeds,
                ...windGusts.filter(g => g !== null)
            );
            const yMax = Math.ceil(maxWind / 5) * 5 + 5;
            
            charts['windChart'] = new Chart(document.getElementById('windChart'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Wind Gusts',
                        data: windGusts,
                        borderColor: '#dc2626',
                        borderDash: [2, 2],
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
                        spanGaps: true
                    }, {
                        label: 'Wind Speed',
                        data: windSpeeds,
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointRadius: 0
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            grid: { color: 'rgba(0, 0, 0, 0.05)' },
                            ticks: {
                                callback: value => value + ' mph',
                                font: { size: 9 },
                                stepSize: 5
                            },
                            min: 0,
                            max: yMax
                        }
                    }
                }
            });
            
            setTimeout(setupCrosshair, 100);
        }
        
        async function initializeForecast() {
            try {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('chartsContainer').style.display = 'none';
                document.getElementById('currentConditions').innerHTML = '<div class="loading">Loading...</div>';
                
                const data = await getForecastData();
                
                updateLocationDetails();
                
                const now = new Date();
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })}`;
                
                const hourlyData = processGriddedDataToHourly(data.gridded);
                
                createCurrentConditions(hourlyData);
                createCurrentForecast(data.daily);
                createDailyForecast(data.daily, hourlyData);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('chartsContainer').style.display = 'block';
                
                createCharts(hourlyData);
                
            } catch (error) {
                console.error("Failed to initialize forecast:", error);
            }
        }
        
        initializeForecast();
        setInterval(initializeForecast, 30 * 60 * 1000);
    </script>

</body>
</html>
